Остало
======

``Разврстати``

Елиминисање дупликата (DISTINCT)
--------------------------------

У неким случајевима желимо да елиминишемо дупликате из резултата
тј. желимо да добијемо само јединствене вредности унутар неке
колоне. То се постиже навођењем ``DISTINCT`` уз име колоне.

.. questionnote::

   Приказати сва различита имена ученика (без понављања).

.. code-block:: sql

   SELECT DISTINCT ime
   FROM ucenik;

Ако бисмо желели да имена буду сортирана по азбучном реду, додали
бисмо клаузулу ``ORDER BY``.

.. code-block:: sql

   SELECT DISTINCT ime
   FROM ucenik
   ORDER BY ime;


.. questionnote::

   Приказати све различите датуме у којима ученик са идентификатором 1
   има изостанке.

.. code-block:: sql

   SELECT DISTINCT datum
   FROM izostanak
   WHERE id_ucenik = 1;
   
.. questionnote::

   Приказати сва различита женска имена ученица школе. 

.. code-block:: sql

   SELECT DISTINCT ime
   FROM ucenik
   WHERE pol = 'ж';

Агрегатне функције (SUM, AVG, MIN, MAX, COUNT)
----------------------------------------------

У применама је јако често израчунати одређене статистике серија
података. То може бити збир, производ, просек тј. аритметичка средина,
најмања или највећа вредност и слично. Приликом израчунавања ових
статистика од серије елемената (тј. од свих елемената једне колоне
табеле) гради се један резултат тј. сви подаци се агрегирају у
јединствен резултат. Зато се ове функције називају **агрегатне
функције**.

Илуструјмо их све на неколико примера. 

Збир елемената неке колоне се може добити агрегатном функцијом
``SUM``.

.. questionnote::
   
   Приказати укупан фонд часова свих предмета.

.. code-block:: sql
                
   SELECT SUM(fond)
   FROM predmet;


Овај упит можемо протумачити као *прочитај збир свих вредности у
колони фонд из свих врста из табеле предмета*.

Примећујемо да за разлику од ранијих упита када је заглавље табеле
садржало имена колона које су наведене након ``SELECT``, овај пут
колона резултата нема неко илустративно име, већ само назив примењене
агрегатне функције. То је могуће променити навођењем тзв. **алијаса**
након кључне речи ``AS``.

.. code-block:: sql
                
   SELECT SUM(fond) AS ukupan_fond
   FROM predmet;


Агрегатне функције се веома често примењују након филтрирања
(рестрикције). За разлику од претходног, за наредним упитом се сасвим
природно може јавити потреба када се рачуна оптерећење ученика.

.. questionnote::
   
   Приказати укупан фонд часова предмета из првог разреда.
 
.. code-block:: sql
                
   SELECT SUM(fond)
   FROM predmet
   WHERE razred = 1;

Овај упит можемо протумачити као *прочитај збир свих вредности у
колони фонд из свих врста из табеле предмета код којих је разред
једнак 1*.

Просек (аритметичку средину) елемената неке колоне се може добити
агрегатном функцијом ``AVG``.

.. questionnote::

   Приказати просечну оцену из предмета са идентификатором 1
   
.. code-block:: sql

   SELECT AVG(ocena)
   FROM ocena
   WHERE id_predmet = 1;


Најмању вредност у некој колони можемо одредити функцијом ``MIN``, а
највећу функцијом ``MAX``. Ове функције се могу применити и на бројеве
и на ниске и на датуме.
   
.. questionnote::

   Приказати најнижу оцену на писменом задатку из математике
   одржаном 18. маја 2021.
   
.. code-block:: sql
                
   SELECT MIN(ocena)
   FROM ocena
   WHERE id_predmet = 1 AND datum = '2021-05-18' AND vrsta = 'писмени задатак';

.. questionnote::

   Приказати датум када је у дневник уписана последња оцена из српског
   језика за први разред
   
.. code-block:: sql

   SELECT MAX(datum)
   FROM ocena
   WHERE id_predmet = 2;

Често желимо да одредимо број елемената неке серије. У случају упита
читања података из база то се најчешће своди на то да се изброје врсте
у резултату упита. За то се користи агрегатна функција
``COUNT``. Пошто је број врста у резултату једнак броју елемената
сваке појединачне колоне, обично се уместо назива колоне, као аргумент
ове функције просто наводи звездица ``*``.
   
.. questionnote::

   Приказати број ученика у табели ученика.

.. code-block:: sql
                
   SELECT COUNT(*)
   FROM ucenik;

Овај упит можемо протумачимо као *прочитај број свих врста из табеле
ученика*.

Исти резултат би се добио ако би тражило пребројавање елемената било
које конкретне колоне. На пример.

.. code-block:: sql
                
   SELECT COUNT(ime)
   FROM ucenik;

И пребројавање често иде у комбинацији са филтрирањем (рестрикцијом).
   
.. questionnote::

   Приказати укупан број предмета у првом разреду
   
.. code-block:: sql

   SELECT COUNT(*)
   FROM predmet
   WHERE razred = 1;

Груписање и израчунавање статистика појединачних група (GROUP BY)
-----------------------------------------------------------------

У претходном поглављу смо видели како се агрегатне функције могу
применити на филтриране податке (податке који задовољавају неки
услов). Видели смо, на пример, како можемо избројати предмете у првом
разреду или како можемо одредити просек свих датих оцена из неког
појединачног предмета. Често се јавља потреба да се иста врста упита
понови за сваку вредност у некој колони. На пример, сасвим је природно
пожелети да се одреди број предмета у сваком од четири разреда или да
се израчуна просечна оцена из сваког појединачног предмета. Уместо да
се прави више сличних упита, овакве статистике је могуће израчунати
коришћењем **груписања и израчунавања статистика по групама**. У
језику SQL се за то користи клаузула ``GROUP BY``.

.. questionnote::
   
   Приказати број предмета у сваком од разреда.

.. code-block:: sql

   SELECT razred, COUNT(*) as broj_predmeta
   FROM predmet
   GROUP BY razred;

Приликом извршавања овог упита скуп свих врста у табели предмета
(свака од њих одговара једном предмету) се подели у четири групе које
одговарају сваком од четири разреда, а затим се агрегатна функција
``COUNT`` примени засебно на сваку од те четири групе.


.. questionnote::
   
   Приказати најмању оцену из сваког предмета.
   
.. code-block:: sql
                
   SELECT id_predmet, MIN(ocena) as min_ocena
   FROM ocena
   GROUP BY id_predmet;

Груписање је могуће извршити и над више колона.

.. questionnote::

   Приказати број ученика у сваком од одељења.

.. code-block:: sql
   
   SELECT razred, odeljenje, COUNT(*) as broj_ucenika
   FROM ucenik
   GROUP BY razred, odeljenje;

У овом случају се за сваки пар вредности ``(razred, odeljenje)``
креира посебна група врста и затим се одреди број елемената (врста) у
свакој од тих група.

Груписање и израчунавање статистика по групама је могуће вршити и
након филтрирања (тј. рестрикције).

.. questionnote::

   Приказати број девојчица у сваком разреду.
   
.. code-block:: sql
   
   SELECT razred, COUNT(*) as broj_devojcica
   FROM ucenik
   WHERE pol = 'ж'
   GROUP BY razred;

Рестрикција након груписања (HAVING)
....................................

Када се израчунају статистике по групама, можемо пожелети да поново
филтрирамо податке тј. да одаберемо које групе желимо да буду
приказане на основу вредности израчунатих статистика. На пример,
можемо израчунати број ученика у сваком одељењу и затим приказати само
она одељења која имају више од 30 ученика. За то се може користити
клаузула ``HAVING``. Дакле, клаузулу ``WHERE`` користимо да бисмо
извршили филтрирање података пре груписања, а ``HAVING`` након
груписања и израчунавања агрегатних статистика.


.. questionnote::

   Приказати одељења у којима има више од 30 ученика.

 
.. code-block:: sql
   
   SELECT razred, odeljenje, COUNT(*) as broj_ucenika
   FROM ucenik
   GROUP BY razred, odeljenje
   HAVING broj_ucenika >= 30;


Упит може да садржи двоструко филтрирање (и ``WHERE`` и ``HAVING``).
   
.. questionnote::

   Приказати одељења у којима има мање од 5 девојчица.
   
.. code-block:: sql
   
   SELECT razred, odeljenje, COUNT(*) as broj_devojcica
   FROM ucenik
   WHERE pol = 'ж'
   GROUP BY razred, odeljenje
   HAVING broj_devojcica < 5;

Спајање
-------

Сви досадашњи упити су читали податке искључиво из једне табеле. Са
друге стране, организација података у базама је таква да се
информације добијају тако што се подаци читају из више табела
истовремено. Наиме, већ смо видели да смештање свих података у једну
велику табелу доводи до редундантности, неефикасности и повећава
могућност настанка грешака.

.. questionnote::

   Приказати све изостанке на дан 14. 5. 2021.         

Први покушај може бити просто читање свих података из табеле изостанака.
   
.. code-block:: sql

   SELECT *
   FROM izostanak
   WHERE datum = '2021-05-14';

Кључни проблем са овим упитом је то што се не виде имена ученика, већ
само њихови идентификатори. Пошто желимо да добијемо што прегледнији
резултат, потребно је да извршимо спајање табеле изостанака и табеле
ученика и то тако што ћемо за сваки идентификатор ученика који је
записан у табели изостанака пронаћи податке о ученику са тим
идентификатором (пре свега његово име и презиме). Један начин да се
споје подаци из две табеле је да се употреби оператор спајања
``... JOIN ... ON ...``.
   
.. code-block:: sql
                
   SELECT *
   FROM izostanak JOIN ucenik ON izostanak.id_ucenik = ucenik.id;

У овом упиту смо извршили спајање табела изостанака и табеле ученика
коришћењем једнакости одговарајућих идентификатора. Резултат ће
садржати све врсте које се добијају тако што се узме по једна врста из
табеле изостанака и из табеле ученика тако да је вредност колоне
``id_ucenik`` у табели изостанака једнака вредности колоне ``id`` у
табели ученика. На пример, претпоставимо да у табели изостанака
постоји врста ``(2, 1, 2021-05-14, 2, неоправдан)``, а у табели
ученика постоји врста ``(1, Петар, Петровић, м, 2007-07-01, 1,
1)``. При том је други број у табели изостанака колона ``id_ucenik``
(идентификатор ученика који је направио изостанак), док је први број у
табели ученик заправо колона ``id`` (идентификатор ученика). Пошто се
у обе те колоне налази вредност 1 (ради се о истом ученику) у спојеној
табели ће постојати врста ``(2, 1, 2021-05-14, 2, неоправдан, 1,
Петар, Петровић, м, 2007-07-01, 1, 1)``.

Приметимо да смо у услову спајања ``ON`` називе колона оквалификовали
називима табела. Што се тиче колоне ``id`` то је било неопходно, јер
колона ``id`` постоји у обе наведене табеле. Са друге стране, колона
``id_ucenik`` постоји само у табели изостанака, па је није било
неопходно наводити назив табеле уз назив колоне, међутим, експлицитним
навођењем имена табеле упит постаје јаснији и прегледнији.

Текст упита се може мало скратити ако се табелама привремено дају
нова, краћа имена, навођењем **алијаса**.

.. code-block:: sql
                
   SELECT *
   FROM izostanak AS i
        JOIN ucenik AS u ON i.id_ucenik = u.id;

Кључна реч ``AS`` се у овом случају може изоставити (``FROM izostanak
i JOIN ucenik u ON ...``).
   
Спојене табеле се могу филтрирати (коришћењем клаузуле ``WHERE``) и
могуће је резултат пројектовати само на оне колоне које нас
занимају. Напоменимо да се филтрирање, ефикасности ради, врши пре
спајања.

.. code-block:: sql
                
   SELECT ime, prezime, cas, status
   FROM izostanak i
        JOIN ucenik u ON i.id_ucenik = u.id
   WHERE datum = '2021-05-14';

Још један начин да се спајање табела изврши је тзв. **имплицитно
спајање**. Наиме, ако се након ``FROM`` наведе више табела раздвојених
зарезима, израчунава се њихов **Декартов производ** тј. свака врста
прве табеле се комбинује (надовезује) са сваком врстом друге табеле.
На пример,

.. code-block:: sql
                
   SELECT *
   FROM izostanak, ucenik;

Од свих ових врста, нама су релевантне само оне у којима је
идентификатор ученика из табеле изостанака једнак идентификатору из
табеле ученика и њих можемо издвојити клаузулом ``WHERE``.


.. code-block:: sql
                
   SELECT *
   FROM izostanak i, ucenik u
   WHERE i.id_ucenik = u.id;

Наравно, могуће је навести и додатан услов у ком се ограничавамо само
на жељени датум.


.. code-block:: sql
                
   SELECT *
   FROM izostanak i, ucenik u
   WHERE i.id_ucenik = u.id AND datum = '2021-05-14';

Ипак, експлицитно спајање је пожељније користити од имплицитног (упити
су јаснији, а на неким системима за управање базама података могу бити
и ефикаснији).

.. questionnote::
                
   Приказати све оцене из математике за први разред.

Главни проблем приликом реализације овог упита је то што не знамо
идентификатор тог предмета. Оцене се налазе у табели оцена, док се
идентификатори предмета налазе у табели предмета и једно могуће решење
је да се прво изврши спајање те две табеле, да би се затим филтирање
могло вршити на основу назива предмета и разреда у ком се предаје
(који су нам познати) уместо на основу идентификатора предмета који
нам је непознат (претпоставићемо да постоји само један предмет у првом
разреду који се зове математика тј. да ако постоји више таквих
предмета да ћемо приказивати оцене из свих тих предмета).

.. code-block:: sql

   SELECT id_ucenik, ocena, datum, vrsta
   FROM ocena
        JOIN predmet ON ocena.id_predmet = predmet.id
   WHERE predmet.naziv = 'Математика' AND predmet.razred = 1;

   
Спајање је могуће применити и на више табела.

.. questionnote::
           
   Приказати све оцене у читљивом формату (тако да се виде име и
   презиме ученика и назив предмета)

.. code-block:: sql

   SELECT p.naziv, u.ime, u.prezime, o.ocena, o.datum, o.vrsta
   FROM ocena o
        JOIN predmet p ON o.id_predmet = p.id
        JOIN ucenik u ON o.id_ucenik = u.id;

Наравно, и тада је могуће извршити додатно филтрирање коришћењем
клаузуле ``WHERE``.

.. questionnote::

   Приказати све оцене на писменим задацима из предмета првог разреда
   у читљивом формату.

.. code-block:: sql
                
   SELECT p.naziv, u.ime, u.prezime, o.ocena, o.datum, o.vrsta
   FROM ocena o
        JOIN predmet p ON o.id_predmet = p.id
        JOIN ucenik u ON o.id_ucenik = u.id
   WHERE p.razred = 1 AND vrsta = 'писмени задатак';

Табеле при спајању не морају бити различите -- могуће је спојити
табелу саму са собом.

.. questionnote::

   Приказати све парове близанаца (под близанцима ћемо подразумевати
   све парове ученика који се исто презивају и имају исти датум
   рођења).

Први покушај подразумева само да се табела ``ucenik`` споји сама са
собом, уз услов да презиме и датум рођења буду једнаки.

.. code-block:: sql

   SELECT u1.ime as ime1, u2.ime as ime2, u1.prezime
   FROM ucenik as u1
        JOIN ucenik as u2 ON u1.datum_rodjenja = u2.datum_rodjenja AND u1.prezime = u2.prezime;

Као што видимо, постоје два проблема са овим приступом. Наиме, сваки
ученик има исти датум рођења и презиме као он сам, па се за сваког
ученика пријављује да је сам себи близанац. Даље, сваки пар близанаца
се пријављује два пута (јер се за првог близанца успешно налази пар,
па се затим и за другог близанца успешно налази пар). И један и други
проблем се могу решити ако се наметне да су идентификатори унутар пара
близанаца различити (тиме се елиминише могућност да је неко сам себи
близанац) и уређени у неком редоследу (тиме се елиминише двоструко
пријављивање истих парова близанаца).

.. code-block:: sql

   SELECT u1.ime as ime1, u2.ime as ime2, u1.prezime
   FROM ucenik as u1
        JOIN ucenik as u2 ON u1.datum_rodjenja = u2.datum_rodjenja AND u1.prezime = u2.prezime
   WHERE u1.id < u2.id;
   
**Ко жели да зна више?** У базама података постоји неколико различитих
оператора спајања: ``INNER JOIN``, ``CROSS JOIN``, ``LEFT JOIN``,
``RIGHT JOIN``, ``FULL JOIN`` који се углавном разликују по томе шта
се дешава када у једној од спојених табела не постоји врста која би
требало да се споји. Оператор ``JOIN`` који смо приказали је заправо
оператор ``INNER JOIN`` (тзв. унутрашње спајање). То је најчешће
коришћена врста спајања, па се стога назнака о којој врсти спајања је
реч може изоставити.

Природно је очекивати да се у табели изостанака налазе само они
идентификатори ученика за које у табели ученика постоје одговарајући
подаци. То је осигурано постављањем *страног кључа* између колоне
``id_ucenik`` у табели изостанака и колоне ``id`` у табели ученика.

Међутим, сасвим је могуће да се вредност колоне ``id`` из неких редова 
табеле ученика уопште не појављује у колони ``id_ucenik`` у 
табели изостанака (јер могу да постоје ученици који немају ниједан 
изостанак). Размотримо тада следећи задатак.

.. questionnote::

   Приказати списак свих ученика са њиховим изостанцима.

Ако бисмо извршили обично (унутрашње) спајање табеле ученика и табеле
изостанака, добили бисмо податке само о оним ученицима који имају
изостанке.


.. code-block:: sql
                
   SELECT *
   FROM ucenik u
        JOIN izostanak i ON u.id = i.id_ucenik;

Ако желимо да се прикажу подаци и о ученицима који немају изостанке,
потребно је да применимо тзв. лево спољашње спајање које се постиже
оператором ``LEFT OUTER JOIN`` или скраћено ``LEFT JOIN``.


.. code-block:: sql
                
   SELECT *
   FROM ucenik u
        LEFT JOIN izostanak i ON u.id = i.id_ucenik;

Код ученика који имају изостанака, за сваки изостанак постоји
одговарајућа врста у резултату. Код ученика који немају изостанака у
пољима који описују изостанак стоје специјалне **недостајуће
вредности** (``NULL``).

Детаљније изучавање разних врста спајања превазилази градиво овог
предмета и тиме се нећемо бавити у наставку.


Спајање и груписање
...................

   
.. questionnote::
                
   Приказати просечне оцене из свих предмета из првог разреда.

Јасно је да је потребно извршити груписање оцена из табеле оцена на
основу предмета (тј. њихових идентификатора) и затим израчунати
статистику (аритметичку средину) за сваку групу посебно. Проблем је то
што се захтева филтрирање предмета тако да се прикажу само просечне
оцене за предмете из првог разреда, међутим, подаци о разреду у ком се
предмет предаје се не налази у табели оцена, већ у табели
предмета. Стога је пре класичног груписања и израчунавања статистика
по групама потребно спојити табелу оцена и табелу предмета.
   
.. code-block:: sql

   SELECT naziv, AVG(ocena) AS prosek
   FROM ocena
        JOIN predmet on ocena.id_predmet = predmet.id
   WHERE razred = 1
   GROUP BY predmet.id;

.. questionnote::

   Приказати просечне оцене из свих предмета (уређене опадајуће по
   просечној оцени).

Овај упит је сличан претходном. Када бисмо се задовољили приказом
просечних оцена и идентификатора предмета, тада бисмо могли применити
само груписање и израчунавање просека група из табеле са
оценама. Међутим, пошто желимо да прикажемо називе предмета, а подаци
о њима се налазе у табели предмета, вршимо спајање две табеле.
   
.. code-block:: sql
                
   SELECT naziv, AVG(ocena) AS prosek
   FROM ocena
        JOIN predmet on ocena.id_predmet = predmet.id
   GROUP BY predmet.id
   ORDER BY prosek DESC;

Могуће је користити и клаузулу ``HAVING`` (подсетимо се, она служи за
филтрирање након груписања на основу израчунатих вредности статистика
група).
   
.. questionnote::
   
   Приказати називе предмета и просечне оцене на писменим задацима за
   све предмете код којих је просечна оцена на писменим задацима бар
   3.50.

.. code-block:: sql
                
   SELECT naziv, AVG(ocena) AS prosek
   FROM ocena
        JOIN predmet ON ocena.id_predmet = predmet.id
   WHERE ocena.vrsta = 'писмени задатак'
   GROUP BY predmet.id
   HAVING prosek >= 3.50;

   
Угнежђени упити
---------------

Код сложенијих упита може бити корисно да се упит формира тако да се
до резултата долази кроз неколико фаза. Свака фаза се формулише као
нови ``SELECT`` упит који поред полазних табела може да користи и
резултат упита из претходне фазе.

Прикажимо ово кроз неколико примера.

.. questionnote::
           
   Приказати највећи број остварених оправданих изостанака неког
   ученика.

У првој фази ћемо формулисати упит који за сваког ученика израчунава
број оправданих изостанака. Ово је класичан упит у ком се врши
груписање и израчунавање статистика (овај пут броја елемената сваке
групе).
   
.. code-block:: sql

   SELECT COUNT(*) AS broj
   FROM izostanak
   WHERE status = 'оправдан'
   GROUP BY id_ucenik

Коначан резултат можемо добити тако што из табеле која се добија као
резултат претходног упита израчуна максимална вредност колоне
``broj``. То се лако постиже коришћењем агрегатне функције ``MAX``.
   
.. code-block:: sql
                
   SELECT MAX(broj)
   FROM
       (SELECT COUNT(*) AS broj
        FROM izostanak
        WHERE status = 'оправдан'
        GROUP BY id_ucenik);


.. questionnote::
           
   Приказати просечне оцене свих предмета који се предају у првом
   разреду.

Овај задатак се може решити спајањем (и то је пожељно решење, поготово
ако се жели приказ назива предмета). Могуће је и решење засновано на
угнежђеним упитима тако што се у првој фази из табеле предмета издвоје
идентификатори предмета који се предају у првом разреду, а онда се тај
скуп идентификатора у другој фази употреби за издвајање одговарајућих
оцена из табеле оцена, пре груписања и рачунања статистика по групама.
   
        
.. code-block:: sql
        
   SELECT id_predmet, AVG(ocena) AS prosek
   FROM ocena
   WHERE id_predmet IN (SELECT id
                        FROM predmet
                        WHERE razred = 1)
   GROUP BY id_predmet;

.. questionnote::
           
   Приказати називе предмета и просечне оцене на писменим задацима за
   све предмете код којих је просечна оцена на писменим задацима бар
   3,50.

Када бисмо се задовољили само приказом идентификатора предмета, онда
бисмо све могли да решимо упитом над табелом оцена, груписањем на
основу идентификатора предмета, израчунавањем просека оцена за сваку
групу и затим рестрикцијом на оне предмете код којих је просечна оцена
већа од 3,5. Пошто су нам потребни називи предмета, можемо извршити
спајање овако добијеног резултата упита са табелом предмета у којој се
налазе идентификатори и називи предмета.
   
.. code-block:: sql
                
   SELECT naziv, prosek
   FROM predmet
        JOIN (SELECT id_predmet, AVG(ocena) AS prosek
              FROM ocena
              WHERE ocena.vrsta = 'писмени задатак'
              GROUP BY id_predmet
              HAVING prosek >= 3.50)
          ON predmet.id = id_predmet;

          
.. questionnote::
           
   За свако одељење приказати највећи број оправданих изостанака.

У првој фази можемо изградити табелу која за сваког ученика садаржи
идентификатор, разред и одељење и број оправданих изостанака. Пошто се
разред и одељење налазе у табели ученика, а број изостанака се рачуна
на основу података у табели изостанака, прво вршимо спајање те две
табеле, вршимо рестрикцију само на оправдане изостанек, а након тога
групишемо податке на основу идентификатора ученика и применом
``COUNT(*)`` одређујемо број оправданих изостанака.

.. code-block:: sql

   SELECT ucenik.id, razred, odeljenje, COUNT(*) as broj_opravdanih
   FROM izostanak
        JOIN ucenik on izostanak.id_ucenik = ucenik.id
   WHERE status = 'оправдан'
   GROUP BY ucenik.id

Када је у првој фази одређена оваква помоћна табела, тада у другој
фази лако можемо одредити максимални број оправданих изостанака за
свако одељење (груписањем на основу разреда и одељења и применом
агрегатне функције ``MAX``).
   
.. code-block:: sql
                
   SELECT razred, odeljenje, MAX(broj_opravdanih)
   FROM (SELECT ucenik.id, razred, odeljenje, COUNT(*) as broj_opravdanih
         FROM izostanak
              JOIN ucenik on izostanak.id_ucenik = ucenik.id
         WHERE status = 'оправдан'
         GROUP BY ucenik.id)
   GROUP BY razred, odeljenje;

Приметимо да табела добијена као резултат угнежђеног подупита нема
назив. Ако је потребно да јој дамо назив, то се може урадити навођењем
**алијаса**, коришћењем кључне речи ``AS`` (у облику ``FROM (SELECT
...) AS naziv``). Алијасе смо раније користили за именовање колона,
док се овај пут именује табела.
   
Сви приказани угнежђени подупити до сада су били такви да се унутрашњи
упит (тзв. подупит) може извршити независно од спољашњег. Међутим, SQL
допушта и да се у унутрашњем упиту врши филтрирање на основу вредности
наведене у спољашњем подупиту. У том случају кажемо да су упити
**корелисани**.

.. questionnote::
           
   Приказати податке о изостанцима ученика који се зову Петар.

Овај упит се природно може написати коришћењем спајања табела ученика
и изостанака. Ипак, приказаћемо решење које користи корелисани
подупит. У спољашњем упиту читамо податке из табеле изостанака, а у
подупиту читамо име ученика чији идентификатор одговара идентификатору
у текућој врсти прочитаној из табеле изостанака и онда изостанке
филтрирамо на основу тога да ли је тако добијено име једнако
``Петар``.
   
.. code-block:: sql

   SELECT *
   FROM izostanak i
   WHERE 'Петар' = (SELECT ime
                    FROM ucenik u
                    WHERE u.id = i.id_ucenik);

   
Провера постојања (EXISTS)
--------------------------

Некада желимо да издвојимо само оне врсте за које корелисани подупит
враћа непразну (или празну) табелу тј. ако се утврди да постоји (или
да не постоји) нека врста која задовољава услов корелисаног подупита.
За то се може користити услов ``EXISTS`` (или ``NOT EXISTS``, који је
заправо само негација услова ``EXISTS``).

.. questionnote::

   Приказати имена ученика који имају неоправдане изостанке.
   
.. code-block:: sql
                
   SELECT id, ime, prezime
   FROM ucenik
   WHERE EXISTS (SELECT *
                 FROM izostanak
                 WHERE izostanak.id_ucenik = ucenik.id AND status = 'неоправдан');

Наравно, постоје и други начини да се овај упит реализује. На пример,
можемо спојити табелу ученика и табелу изостанака, груписати изостанке
по свим ученицима, и приказати имена и презимена за сваку групу
(приметимо да овде не примењујемо ни једну агрегатну функцију на
формиране групе).

.. code-block:: sql

   SELECT ucenik.id, ime, prezime
   FROM ucenik JOIN
        izostanak on izostanak.id_ucenik = ucenik.id
   WHERE status = 'неоправдан'
   GROUP BY ucenik.id;
                
У наредном проблему, можемо искористити услов непостојања ``NOT
EXISTS``.
                 
.. questionnote::
           
   Приказати имена ученика који немају нерегулисаних изостанака.
   
.. code-block:: sql
                
   SELECT id, ime, prezime
   FROM ucenik
   WHERE NOT EXISTS (SELECT *
                     FROM izostanak
                     WHERE izostanak.id_ucenik = ucenik.id AND status = 'нерегулисан');
