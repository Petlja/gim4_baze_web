.. -*- mode: rst -*-
   
Угнежђени упити
---------------

Код сложенијих упита може бити корисно да се упит формира тако да се
до резултата долази кроз неколико фаза. Свака фаза се формулише као
нови ``SELECT`` упит који поред полазних табела може да користи и
резултат упита из претходне фазе.

Прикажимо ово кроз неколико примера.

.. questionnote::
           
   Приказати највећи број остварених оправданих изостанака неког
   ученика.

У првој фази ћемо формулисати упит који за сваког ученика израчунава
број оправданих изостанака. Ово је класичан упит у ком се врши
груписање и израчунавање статистика (овај пут броја елемената сваке
групе).
   
.. code-block:: sql

   SELECT COUNT(*) AS broj
   FROM izostanak
   WHERE status = 'оправдан'
   GROUP BY id_ucenik

Коначан резултат можемо добити тако што из табеле која се добија као
резултат претходног упита израчуна максимална вредност колоне
``broj``. То се лако постиже коришћењем агрегатне функције ``MAX``.
   
.. code-block:: sql
                
   SELECT MAX(broj)
   FROM
       (SELECT COUNT(*) AS broj
        FROM izostanak
        WHERE status = 'оправдан'
        GROUP BY id_ucenik);


.. questionnote::
           
   Приказати просечне оцене свих предмета који се предају у првом
   разреду.

Овај задатак се може решити спајањем (и то је пожељно решење, поготово
ако се жели приказ назива предмета). Могуће је и решење засновано на
угнежђеним упитима тако што се у првој фази из табеле предмета издвоје
идентификатори предмета који се предају у првом разреду, а онда се тај
скуп идентификатора у другој фази употреби за издвајање одговарајућих
оцена из табеле оцена, пре груписања и рачунања статистика по групама.
   
        
.. code-block:: sql
        
   SELECT id_predmet, AVG(ocena) AS prosek
   FROM ocena
   WHERE id_predmet IN (SELECT id
                        FROM predmet
                        WHERE razred = 1)
   GROUP BY id_predmet;

.. questionnote::
           
   Приказати називе предмета и просечне оцене на писменим задацима за
   све предмете код којих је просечна оцена на писменим задацима бар
   3,50.

Када бисмо се задовољили само приказом идентификатора предмета, онда
бисмо све могли да решимо упитом над табелом оцена, груписањем на
основу идентификатора предмета, израчунавањем просека оцена за сваку
групу и затим рестрикцијом на оне предмете код којих је просечна оцена
већа од 3,5. Пошто су нам потребни називи предмета, можемо извршити
спајање овако добијеног резултата упита са табелом предмета у којој се
налазе идентификатори и називи предмета.
   
.. code-block:: sql
                
   SELECT naziv, prosek
   FROM predmet
        JOIN (SELECT id_predmet, AVG(ocena) AS prosek
              FROM ocena
              WHERE ocena.vrsta = 'писмени задатак'
              GROUP BY id_predmet
              HAVING prosek >= 3.50)
          ON predmet.id = id_predmet;

          
.. questionnote::
           
   За свако одељење приказати највећи број оправданих изостанака.

У првој фази можемо изградити табелу која за сваког ученика садаржи
идентификатор, разред и одељење и број оправданих изостанака. Пошто се
разред и одељење налазе у табели ученика, а број изостанака се рачуна
на основу података у табели изостанака, прво вршимо спајање те две
табеле, вршимо рестрикцију само на оправдане изостанек, а након тога
групишемо податке на основу идентификатора ученика и применом
``COUNT(*)`` одређујемо број оправданих изостанака.

.. code-block:: sql

   SELECT ucenik.id, razred, odeljenje, COUNT(*) as broj_opravdanih
   FROM izostanak
        JOIN ucenik on izostanak.id_ucenik = ucenik.id
   WHERE status = 'оправдан'
   GROUP BY ucenik.id

Када је у првој фази одређена оваква помоћна табела, тада у другој
фази лако можемо одредити максимални број оправданих изостанака за
свако одељење (груписањем на основу разреда и одељења и применом
агрегатне функције ``MAX``).
   
.. code-block:: sql
                
   SELECT razred, odeljenje, MAX(broj_opravdanih)
   FROM (SELECT ucenik.id, razred, odeljenje, COUNT(*) as broj_opravdanih
         FROM izostanak
              JOIN ucenik on izostanak.id_ucenik = ucenik.id
         WHERE status = 'оправдан'
         GROUP BY ucenik.id)
   GROUP BY razred, odeljenje;

Приметимо да табела добијена као резултат угнежђеног подупита нема
назив. Ако је потребно да јој дамо назив, то се може урадити навођењем
**алијаса**, коришћењем кључне речи ``AS`` (у облику ``FROM (SELECT
...) AS naziv``). Алијасе смо раније користили за именовање колона,
док се овај пут именује табела.
