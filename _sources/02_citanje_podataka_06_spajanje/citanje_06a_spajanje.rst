.. -*- mode: rst -*-

Спајање
-------

Сви досадашњи упити су читали податке искључиво из једне табеле. Са
друге стране, организација података у базама је таква да се
информације добијају тако што се подаци читају из више табела
истовремено. Наиме, већ смо видели да смештање свих података у једну
велику табелу доводи до редундантности, неефикасности и повећава
могућност настанка грешака.

.. questionnote::

   Приказати све изостанке на дан 14. 5. 2021.         

Први покушај може бити просто читање свих података из табеле изостанака.
   
.. code-block:: sql

   SELECT *
   FROM izostanak
   WHERE datum = '2021-05-14';

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "id", "id_ucenik", "datum", "cas", "status"

   1, 1, 2021-05-14, 1, оправдан
   2, 1, 2021-05-14, 2, неоправдан
   3, 4, 2021-05-14, 1, нерегулисан
   4, 4, 2021-05-14, 2, нерегулисан
   ..., ..., ..., ..., ...

Кључни проблем са овим упитом је то што се не виде имена ученика, већ
само њихови идентификатори. Пошто желимо да добијемо што прегледнији
резултат, потребно је да извршимо спајање табеле изостанака и табеле
ученика и то тако што ћемо за сваки идентификатор ученика који је
записан у табели изостанака пронаћи податке о ученику са тим
идентификатором (пре свега његово име и презиме). Један начин да се
споје подаци из две табеле је да се употреби оператор спајања
``... JOIN ... ON ...``.
   
.. code-block:: sql
                
   SELECT *
   FROM izostanak JOIN ucenik ON izostanak.id_ucenik = ucenik.id;

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "id", "id_ucenik", "datum", "cas", "status", "id", "ime", "prezime", "pol", "datum_rodjenja", "razred", "odeljenje"

   1, 1, 2021-05-14, 1, оправдан, 1, Петар, Петровић, м, 2006-07-01, 1, 1
   2, 1, 2021-05-14, 2, неоправдан, 1, Петар, Петровић, м, 2006-07-01, 1, 1
   3, 4, 2021-05-14, 1, нерегулисан, 4, Петар, Миловановић, м, 2005-12-08, 2, 1
   4, 4, 2021-05-14, 2, нерегулисан, 4, Петар, Миловановић, м, 2005-12-08, 2, 1
   ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ...

У овом упиту смо извршили спајање табела изостанака и табеле ученика
коришћењем једнакости одговарајућих идентификатора. Резултат ће
садржати све врсте које се добијају тако што се узме по једна врста из
табеле изостанака и из табеле ученика тако да је вредност колоне
``id_ucenik`` у табели изостанака једнака вредности колоне ``id`` у
табели ученика. На пример, претпоставимо да у табели изостанака
постоји врста ``(2, 1, 2021-05-14, 2, неоправдан)``, а у табели
ученика постоји врста ``(1, Петар, Петровић, м, 2007-07-01, 1,
1)``. При том је други број у табели изостанака колона ``id_ucenik``
(идентификатор ученика који је направио изостанак), док је први број у
табели ученик заправо колона ``id`` (идентификатор ученика). Пошто се
у обе те колоне налази вредност 1 (ради се о истом ученику) у спојеној
табели ће постојати врста ``(2, 1, 2021-05-14, 2, неоправдан, 1,
Петар, Петровић, м, 2007-07-01, 1, 1)``.

Приметимо да смо у услову спајања ``ON`` називе колона оквалификовали
називима табела. Што се тиче колоне ``id`` то је било неопходно, јер
колона ``id`` постоји у обе наведене табеле. Са друге стране, колона
``id_ucenik`` постоји само у табели изостанака, па је није било
неопходно наводити назив табеле уз назив колоне, међутим, експлицитним
навођењем имена табеле упит постаје јаснији и прегледнији.

Текст упита се може мало скратити ако се табелама привремено дају
нова, краћа имена, навођењем **алијаса**.

.. code-block:: sql
                
   SELECT *
   FROM izostanak AS i
        JOIN ucenik AS u ON i.id_ucenik = u.id;

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "id", "id_ucenik", "datum", "cas", "status", "id", "ime", "prezime", "pol", "datum_rodjenja", "razred", "odeljenje"

   1, 1, 2021-05-14, 1, оправдан, 1, Петар, Петровић, м, 2006-07-01, 1, 1
   2, 1, 2021-05-14, 2, неоправдан, 1, Петар, Петровић, м, 2006-07-01, 1, 1
   3, 4, 2021-05-14, 1, нерегулисан, 4, Петар, Миловановић, м, 2005-12-08, 2, 1
   4, 4, 2021-05-14, 2, нерегулисан, 4, Петар, Миловановић, м, 2005-12-08, 2, 1
   ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ...

Кључна реч ``AS`` се у овом случају може изоставити (``FROM izostanak
i JOIN ucenik u ON ...``).
   
Спојене табеле се могу филтрирати (коришћењем клаузуле ``WHERE``) и
могуће је резултат пројектовати само на оне колоне које нас
занимају. Напоменимо да се филтрирање, ефикасности ради, врши пре
спајања.

.. code-block:: sql
                
   SELECT ime, prezime, cas, status
   FROM izostanak i
        JOIN ucenik u ON i.id_ucenik = u.id
   WHERE datum = '2021-05-14';

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "ime", "prezime", "cas", "status"

   Петар, Петровић, 1, оправдан
   Петар, Петровић, 2, неоправдан
   Петар, Миловановић, 1, нерегулисан
   Петар, Миловановић, 2, нерегулисан
   ..., ..., ..., ...


.. questionnote::
                
   Приказати све оцене из математике за први разред.

Главни проблем приликом реализације овог упита је то што не знамо
идентификатор тог предмета. Оцене се налазе у табели оцена, док се
идентификатори предмета налазе у табели предмета и једно могуће решење
је да се прво изврши спајање те две табеле, да би се затим филтирање
могло вршити на основу назива предмета и разреда у ком се предаје
(који су нам познати) уместо на основу идентификатора предмета који
нам је непознат (претпоставићемо да постоји само један предмет у првом
разреду који се зове математика тј. да ако постоји више таквих
предмета да ћемо приказивати оцене из свих тих предмета).

.. code-block:: sql

   SELECT id_ucenik, ocena, datum, vrsta
   FROM ocena
        JOIN predmet ON ocena.id_predmet = predmet.id
   WHERE predmet.naziv = 'Математика' AND predmet.razred = 1;

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "id_ucenik", "ocena", "datum", "vrsta"

   1, 3, 2020-10-15, писмени задатак
   2, 3, 2020-10-15, писмени задатак
   3, 2, 2020-10-15, писмени задатак
   14, 3, 2020-10-15, писмени задатак
   ..., ..., ..., ...

   
Спајање је могуће применити и на више табела.

.. questionnote::
           
   Приказати све оцене у читљивом формату (тако да се виде име и
   презиме ученика и назив предмета)

.. code-block:: sql

   SELECT p.naziv, u.ime, u.prezime, o.ocena, o.datum, o.vrsta
   FROM ocena o
        JOIN predmet p ON o.id_predmet = p.id
        JOIN ucenik u ON o.id_ucenik = u.id;

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "naziv", "ime", "prezime", "ocena", "datum", "vrsta"

   Математика, Петар, Петровић, 3, 2020-10-15, писмени задатак
   Математика, Милица, Јовановић, 3, 2020-10-15, писмени задатак
   Математика, Лидија, Петровић, 2, 2020-10-15, писмени задатак
   Математика, Јована, Божић, 3, 2020-10-15, писмени задатак
   ..., ..., ..., ..., ..., ...

Наравно, и тада је могуће извршити додатно филтрирање коришћењем
клаузуле ``WHERE``.

.. questionnote::

   Приказати све оцене на писменим задацима из предмета првог разреда
   у читљивом формату.

.. code-block:: sql
                
   SELECT p.naziv, u.ime, u.prezime, o.ocena, o.datum, o.vrsta
   FROM ocena o
        JOIN predmet p ON o.id_predmet = p.id
        JOIN ucenik u ON o.id_ucenik = u.id
   WHERE p.razred = 1 AND vrsta = 'писмени задатак';

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "naziv", "ime", "prezime", "ocena", "datum", "vrsta"

   Математика, Петар, Петровић, 3, 2020-10-15, писмени задатак
   Математика, Милица, Јовановић, 3, 2020-10-15, писмени задатак
   Математика, Лидија, Петровић, 2, 2020-10-15, писмени задатак
   Математика, Јована, Божић, 3, 2020-10-15, писмени задатак
   ..., ..., ..., ..., ..., ...

Табеле при спајању не морају бити различите -- могуће је спојити
табелу саму са собом.

.. questionnote::

   Приказати све парове близанаца (под близанцима ћемо подразумевати
   све парове ученика који се исто презивају и имају исти датум
   рођења).

Први покушај подразумева само да се табела ``ucenik`` споји сама са
собом, уз услов да презиме и датум рођења буду једнаки.

.. code-block:: sql

   SELECT u1.ime as ime1, u2.ime as ime2, u1.prezime
   FROM ucenik as u1
        JOIN ucenik as u2 ON u1.datum_rodjenja = u2.datum_rodjenja AND u1.prezime = u2.prezime;

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "ime1", "ime2", "prezime"

   Петар, Петар, Петровић
   Милица, Милица, Јовановић
   Лидија, Лидија, Петровић
   Петар, Петар, Миловановић
   ..., ..., ...

Као што видимо, постоје два проблема са овим приступом. Наиме, сваки
ученик има исти датум рођења и презиме као он сам, па се за сваког
ученика пријављује да је сам себи близанац. Даље, сваки пар близанаца
се пријављује два пута (јер се за првог близанца успешно налази пар,
па се затим и за другог близанца успешно налази пар). И један и други
проблем се могу решити ако се наметне да су идентификатори унутар пара
близанаца различити (тиме се елиминише могућност да је неко сам себи
близанац) и уређени у неком редоследу (тиме се елиминише двоструко
пријављивање истих парова близанаца).

.. code-block:: sql

   SELECT u1.ime as ime1, u2.ime as ime2, u1.prezime
   FROM ucenik as u1
        JOIN ucenik as u2 ON u1.datum_rodjenja = u2.datum_rodjenja AND u1.prezime = u2.prezime
   WHERE u1.id < u2.id;

Извршавањем упита добија се следећи резултат:

.. csv-table::
   :header:  "ime1", "ime2", "prezime"

   Јован, Јована, Миленковић

