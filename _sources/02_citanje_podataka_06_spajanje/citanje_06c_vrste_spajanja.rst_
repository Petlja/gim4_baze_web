Врсте спајања
.............

У базама података постоји неколико различитих оператора спајања:
``INNER JOIN``, ``CROSS JOIN``, ``LEFT JOIN``, ``RIGHT JOIN``, ``FULL
JOIN`` који се углавном разликују по томе шта се дешава када у једној
од спојених табела не постоји врста која би требало да се
споји. Оператор ``JOIN`` који смо приказали је заправо оператор
``INNER JOIN`` (тзв. унутрашње спајање). То је најчешће коришћена
врста спајања, па се стога назнака о којој врсти спајања је реч може
изоставити.

Природно је очекивати да се у табели изостанака налазе само они
идентификатори ученика за које у табели ученика постоје одговарајући
подаци. То је осигурано постављањем *страног кључа* између колоне
``id_ucenik`` у табели изостанака и колоне ``id`` у табели ученика.

Међутим, сасвим је могуће да се вредност колоне ``id`` из неких редова
табеле ученика уопште не појављује у колони ``id_ucenik`` у табели
изостанака (јер могу да постоје ученици који немају ниједан
изостанак). Размотримо тада следећи задатак.

.. questionnote::

   Приказати списак свих ученика са њиховим изостанцима.

Ако бисмо извршили обично (унутрашње) спајање табеле ученика и табеле
изостанака, добили бисмо податке само о оним ученицима који имају
изостанке.

.. code-block:: sql
                
   SELECT *
   FROM ucenik u
        JOIN izostanak i ON u.id = i.id_ucenik;

Ако желимо да се прикажу подаци и о ученицима који немају изостанке,
потребно је да применимо тзв. лево спољашње спајање које се постиже
оператором ``LEFT OUTER JOIN`` или скраћено ``LEFT JOIN``.

.. code-block:: sql
                
   SELECT *
   FROM ucenik u
        LEFT JOIN izostanak i ON u.id = i.id_ucenik;

Код ученика који имају изостанака, за сваки изостанак постоји
одговарајућа врста у резултату. Код ученика који немају изостанака у
пољима који описују изостанак стоје специјалне **недостајуће
вредности** (``NULL``).


Иако на први поглед делује да ово нема пуно смисла, кључна ствар је то
што смо у табели задржали податке о свим ученицима, што ће омогућава
да у извештајима о укупном броју изостанака пријавимо и податке о
ученицима који нису правили изостанке. Илуструјмо то наредним паром
примера.

.. questionnote::

   Приказати укупан број изостанака за сваког ученика (укључујући и
   оне ученике који немају неоправданих изостанака). Списак уредити
   опадајуће по укупном броју изостанака.

Кључни елемент решења је то да агрегатне функције приликом агрегирања
елемената задате колоне потпуно игноришу недостајуће вредности у тој
колони. Тако агрегатна функција ``COUNT`` броји само оне врсте које не
садрже вредности ``NULL``. Зато се применом груписања по
идентификатору ученика и применом функције ``COUNT`` на табелу
добијену левим спољашњим спајањем табеле ученика и изостанака лако
може генерисати извештај који садржи податке о свим ученицима, при
чему ће се код оних који немају изостанака појавити број 0.

.. code-block:: sql
                
   SELECT u.id, u.ime, u.prezime, COUNT(status) AS broj_izostanaka
   FROM ucenik u
        LEFT JOIN izostanak i ON u.id = i.id_ucenik
   GROUP BY u.id
   ORDER BY broj_izostanaka DESC;

.. questionnote::

   Приказати број неоправданих изостанака за сваког ученика одељења I2
   (укључујући и оне ученике који немају неоправданих
   изостанака). Списак уредити опадајуће по броју неоправданих
   изостанака.

Овај пример само проширује претходни тиме што се захтева додатно
филтрирање.

.. code-block:: sql
                
   SELECT u.id, u.ime, u.prezime, COUNT(status) AS broj_neopravdanih
   FROM ucenik u LEFT JOIN
        izostanak i ON u.id = i.id_ucenik AND
        u.razred = 1 AND u.odeljenje = 2 AND status = 'неоправдан'
   GROUP BY u.id
   ORDER BY broj_neopravdanih DESC

Приметимо да смо услов селекције (филтрирања) навели у склопу услова
спајања, а не у склопу клаузуле ``WHERE``, јер бисмо издвајањем само
неоправданих изостанака након спајања изгубили податке о ученицима
који немају изостанака (јер у колони статус не пише ``neopravdan``,
већ ``NULL``). Алтернативно, услов филтрирања у клаузули ``WHERE`` би
се могао записати као ``status = 'неоправдан' OR status IS NULL``,
чиме би се задржале врсте које одговарају неоправданим изостанцима
ученика који их имају, као и врсте које одговарају ученицима који
немају изостанке.

Десно спољашње спајање је симетрично левом (задржавају се све колоне
друге уместо прве табеле).  Детаљније изучавање осталих врста спајања
превазилази градиво овог предмета и тиме се нећемо бавити у
наставку. У већини примера ћемо користити унутрашње спајање
(``JOIN``), а с времена на време ћемо употребити и лево спољашње
спајање (``LEFT JOIN``). Резимирајмо на једном малом примеру како та
два спајања функционишу. Претпоставимо да спајамо следеће две табеле
(``autor`` и ``knjiga``).

.. csv-table::
   :header:  "id", "ime", "prezime"

   1, Петар, Јовановић
   2, Лазар, Бошковић
   3, Милена, Шумановић


.. csv-table::
   :header:  "id_autor", "књига"

   1, Увод у HTML
   1, Стилизовање веб-страница
   3, Програмирање у Python-у

Као што видимо, аутор 1, Петар Јовановић је написао две књиге, аутор 2
није написао ни једну, док је ауторка 3 написала једну књигу.

Унутрашњим спајањем (по услову ``autor.id = knjiga.id_autor``) добили
бисмо следећу табелу.

.. csv-table::
   :header: "id", "ime", "prezime", "id_autor", "књига"

   1, Петар, Јовановић, 1, Увод у HTML
   1, Петар, Јовановић, 1, Стилизовање веб-страница
   3, Милена, Шумановић, 3, Програмирање у Python-у

Левим спољашњим спајањем (по услову ``autor.id = knjiga.id_autor``)
добили бисмо следећу табелу.

.. csv-table::
   :header: "id", "ime", "prezime", "id_autor", "књига"

   1, Петар, Јовановић, 1, Увод у HTML
   1, Петар, Јовановић, 1, Стилизовање веб-страница
   2, Лазар, Бошковић, NULL, NULL
   3, Милена, Шумановић, 3, Програмирање у Python-у


