Постављање упита
----------------

Да би се могао поставити упит, потребно је креирати објекат који се
назива **курсор**. То се ради тако што се над објектом конекције
позове метод ``cursor()``. На пример,


.. code-block:: py

   import sqlite3
   
   conn = sqlite3.connect(...)
   cur = conn.cursor()
   ...
   conn.close()

Упит затим можемо изврши позивом методе ``execute`` на креираном
курсору. Параметар је ниска која садржи текст упита на језику SQL. На
пример, унос новог ученика у табелу се може извршити на следећи начин:

.. code-block:: py

   cur.execute("INSERT INTO ucenik (ime, prezime, razred, odeljenje)" +
               "VALUES ('Петар', 'Петровић', 1, 1)");

Поделу упита на две ниске смо урадили само прегледности ради.

Уколико се ради о неком упиту који врши измене над базом (``INSERT``,
``UPDATE``, ``DELETE``), након извршавања упита (или неколико таквих
упита) потребно је над конекцијом позвати методу ``commit`` којом се
измене трајно уписују у базу. Текст целокупног програма који уписује
новог ученика тада гласи овако.


.. code-block:: py

   import os
   import sqlite3
   
   conn = sqlite3.connect(os.path.join(os.getcwd(), 'dnevnik.db'))
   cur = conn.cursor()
   cur.execute("INSERT INTO ucenik (ime, prezime, razred, odeljenje)" +
               "VALUES ('Петар', 'Петровић', 1, 1)");
   conn.commit()
   conn.close()

   
Ако се методом ``execute`` извршава упит читања података из базе (упит
``SELECT``), тада је повратна вредност позива методе ``execute``
резултујућа табела, смештена у специјализованој структури података
коју можемо посматрати као листу врста, што значи да помоћу петље
``for`` можемо обрађивати једну по једну врсту. Свака врста је уређена
торка. Размотримо наредни програм који чита и исписује имена и
презимена свих ученика.


.. code-block:: py

   import os
   import sqlite3
   
   conn = sqlite3.connect(os.path.join(os.getcwd(), 'dnevnik.db'))
   cur = conn.cursor()
   res = cur.execute("SELECT ime, prezime FROM ucenik");
   for row in res:
       print(row[0], row[1])
   conn.close()

Променљива ``res`` садржи резултат упита, док променљива ``row``
садржи редом једну по једну врсту тог резултата. Врсте су уређени
парови (двочлане торке) и име и презиме се издвајају из њих коришћењем
индексног приступа (``row[0]`` ће бити име, а ``row[1]``
презиме). Читљивији код се може добити ако се петља реализује на следећи начин:

.. code-block:: py
                
   for ime, prezime in res:
       print(ime, prezime)

Нагласимо још једном да је у реалним програмима у склопу упита
``SELECT`` увек пожељно експлицитно навести називе и редослед колона
које се читају из базе. Тај редослед се после користи и у петљама које
обрађују резултате упита, па ако се он упари са оним наведеним након
кључне речи ``SELECT``, тада нема опасности да скрипт престане да ради
ако се структура табела у бази мало промени (нпр. дода се нека нова
колона).

Резултат упита се чува и специјалној структури података кроз коју
можемо итерирати коришћењем петље ``for``. Та структура података није
листа и сасвим је могуће да се врше разне оптимизације које доводе до
тога да се цела табела резултата никада не чува истовремено у
меморији. Листу торки у којој се чува цео резултат могуће је добити
коришћењем метода ``fetchall`` над курсором над којим је извршен упит.
Слично, метода ``fetchone`` враћа наредну врсту у резултату претходно
извршеног упита.
